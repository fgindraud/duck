#pragma once

// Analog to std::unique_ptr<T>, but has a local storage to avoid new() for small objects
// Intended to store small virtual classes with less overhead.

#include <cassert>
#include <duck/type_traits.h> // For InPlace<T> and <type_traits>
#include <memory>
#include <utility>

namespace duck {

// TODO Doc and make nicer
// Maybe have Derived : MakeMovable<Derived, BaseClasses...>
// And MakeMovable<Derived, BaseClasses...> : BaseClasses...
template <typename Base> struct SmallUniquePtrMakeMovableBase {
	virtual ~SmallUniquePtrMakeMovableBase () = default;
	virtual void small_unique_ptr_move (Base * to_storage) noexcept = 0;
};
template <typename Derived, typename Base>
struct SmallUniquePtrMakeMovable : public virtual SmallUniquePtrMakeMovableBase<Base> {
	void small_unique_ptr_move (Base * to_storage) noexcept override {
		auto & derived = static_cast<Derived &> (*this);
		new (to_storage) Derived (std::move (derived));
	}
};

template <typename T, std::size_t StorageSize> class SmallUniquePtr {
	/* This class is analog to unique_ptr<T>, and has a similar API.
	 * However it has a local buffer used instead of allocation if the type is small enough.
	 *
	 * Only polymorphic T types are supported (virtual).
	 * Non polymorphic classes do not benefit from this class.
	 * Either construct them as is, or use unique_ptr (size is fixed).
	 *
	 * To support move operations, T must have a virtual move function.
	 * These functions are automatically generated by inheriting from [..]MakeMovable classes.
	 * A moved/release SmallUniquePtr is nullptr.
	 */
private:
	static_assert (std::is_polymorphic<T>::value,
	               "This class should only be used for polymorphic types");
	using StorageType = typename std::aligned_storage<StorageSize>::type;

public:
	using pointer = T *;
	using const_pointer = const T *;
	static constexpr auto storage_align = alignof (StorageType);
	static constexpr auto storage_size = StorageSize;

	// Constructors
	SmallUniquePtr () = default;
	SmallUniquePtr (std::nullptr_t) noexcept : SmallUniquePtr () {}
	SmallUniquePtr (pointer p) noexcept : data_ (p) {}

	SmallUniquePtr (const SmallUniquePtr &) = delete;
	template <typename U, std::size_t OtherStorageSize>
	SmallUniquePtr (SmallUniquePtr<U, OtherStorageSize> && other) noexcept {
		move_from_other (std::move (other));
	}

	template <typename U, typename... Args> SmallUniquePtr (InPlace<U>, Args &&... args) {
		build<U> (std::forward<Args> (args)...);
	}
	template <typename U, typename V, typename... Args>
	SmallUniquePtr (InPlace<U>, std::initializer_list<V> ilist, Args &&... args) {
		build<U> (std::move (ilist), std::forward<Args> (args)...);
	}

	~SmallUniquePtr () { reset (); }

	SmallUniquePtr & operator= (const SmallUniquePtr &) = delete;
	template <typename U, std::size_t OtherStorageSize>
	SmallUniquePtr & operator= (SmallUniquePtr<U, OtherStorageSize> && other) noexcept {
		reset ();
		move_from_other (std::move (other));
		return *this;
	}

	SmallUniquePtr & operator= (std::nullptr_t) noexcept {
		reset ();
		return *this;
	}

	// Modifiers
	pointer release () noexcept {
		if (data_) {
			if (is_allocated ()) {
				return release_pointer_unsafe ();
			} else {
				auto allocated_storage = create_storage_helper (storage_size, std::false_type{});
				move_to (allocated_storage);
				return allocated_storage;
			}
		} else {
			return nullptr;
		}
	}
	void reset () noexcept {
		if (data_) {
			if (is_allocated ())
				delete data_;
			else
				data_->~T ();
			data_ = nullptr;
		}
	}
	void reset (pointer p) noexcept {
		reset ();
		data_ = p;
	}
	template <typename U = T, typename... Args> void reset (InPlace<U>, Args &&... args) {
		emplace<U> (std::forward<Args> (args)...);
	}
	template <typename U = T, typename V, typename... Args>
	void reset (InPlace<U>, std::initializer_list<V> ilist, Args &&... args) {
		emplace<U> (std::move (ilist), std::forward<Args> (args)...);
	}

	template <typename U = T, typename... Args> void emplace (Args &&... args) {
		reset ();
		build<U> (std::forward<Args> (args)...);
	}
	template <typename U = T, typename V, typename... Args>
	void emplace (std::initializer_list<V> ilist, Args &&... args) {
		reset ();
		build<U> (std::move (ilist), std::forward<Args> (args)...);
	}

	// Observers
	constexpr pointer get () const noexcept { return data_; }
	constexpr operator bool () const noexcept { return data_; }
	pointer operator-> () const noexcept { return data_; }
	typename std::add_lvalue_reference<T>::type operator* () const noexcept { return *data_; }

	// Both functions are undefined is pointer is null
	bool is_inline () const noexcept {
		/* T is polymorphic, we can expect derived classes to be used.
		 * Depending on the layout of derived classes, data_ may be different from the storage pointer.
		 * Checking that data_ == &inline_storage_ is not sufficient.
		 * The condition is to check that data_ is inside the inline_storage_ buffer.
		 */
		auto inline_storage_as_byte = reinterpret_cast<const unsigned char *> (&inline_storage_);
		auto data_as_byte = reinterpret_cast<const unsigned char *> (data_);
		return inline_storage_as_byte <= data_as_byte &&
		       data_as_byte < inline_storage_as_byte + storage_size;
	}
	bool is_allocated () const noexcept { return !is_inline (); }

	// Public internals used for move/release
	pointer release_pointer_unsafe () noexcept {
		// Assume is_allocated ()
		auto tmp = data_;
		data_ = nullptr;
		return tmp;
	}
	void move_to (pointer storage) noexcept {
		// Assume is_inline ()
		data_->small_unique_ptr_move (storage);
		data_->~T ();
		data_ = nullptr;
	}

private:
	/* Condition used to determine if a type U can be built inline.
	 * This is not an equivalence: a type U could be built inline and be stored allocated.
	 * (for example if result of a move)
	 */
	template <std::size_t Size, std::size_t Align>
	using BuildInline =
	    std::integral_constant<bool, (Size <= storage_size && Align <= storage_align)>;
	template <typename U> using BuildTypeInline = BuildInline<sizeof (U), alignof (U)>;

	// create_storage_helper(alloc_size, use_inline_storage)
	pointer create_storage_helper (std::size_t, std::true_type) noexcept {
		return reinterpret_cast<pointer> (&inline_storage_);
	}
	static pointer create_storage_helper (std::size_t size, std::false_type) {
		return static_cast<pointer> (::operator new (size));
	}

	// Create storage for a type U
	template <typename U> pointer create_storage_for_build () {
		return create_storage_helper (sizeof (U), BuildTypeInline<U>{});
	}

	// Create storage of at least Size
	template <typename FromPtr> pointer create_storage_for_move () {
		return create_storage_helper (FromPtr::storage_size,
		                              BuildInline<FromPtr::storage_size, FromPtr::storage_align>{});
	}

	// Static Deleter of storage for a type U
	template <typename U> static void destroy_storage (pointer storage) {
		destroy_storage_helper (storage, BuildTypeInline<U>{});
	}
	static void destroy_storage_helper (pointer, std::true_type) {}
	static void destroy_storage_helper (pointer storage, std::false_type) {
		::operator delete (storage);
	}

	template <typename U, typename... Args> void build (Args &&... args) {
		static_assert (std::is_base_of<T, U>::value, "build object must derive from T");
		// tmp serves as a RAII temporary storage for the buffer : storage is cleaned on Constr error.
		auto deleter = destroy_storage<U>;
		std::unique_ptr<T, decltype (deleter)> tmp{create_storage_for_build<U> (), deleter};
		new (tmp.get ()) U (std::forward<Args> (args)...);
		data_ = tmp.release ();
	}
	template <typename U, std::size_t OtherStorageSize>
	void move_from_other (SmallUniquePtr<U, OtherStorageSize> && other) noexcept {
		static_assert (std::is_base_of<T, U>::value,
		               "can only move from SmallUniquePtr<U> to SmallUniquePtr<T> if U derives from T");
		static_assert (std::is_base_of<SmallUniquePtrMakeMovableBase<T>, T>::value,
		               "move support requires that T derives from SmallUniquePtrMakeMovable<T>");
		if (other) {
			if (other.is_allocated ()) {
				data_ = other.release_pointer_unsafe (); // Just steal pointer
			} else {
				// Call the move constructor to change the storage.
				data_ = create_storage_for_move<SmallUniquePtr<U, OtherStorageSize>> ();
				other.move_to (data_);
			}
		}
	}

	pointer data_{nullptr}; // Points to the T object, not the chosen storage
	StorageType inline_storage_;
};

// Comparison TODO ?

// MakeUnique<T> (Args) -> SmallUniquePtr<T, sizeof T> ?
}
